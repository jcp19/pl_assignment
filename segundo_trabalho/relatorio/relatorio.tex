\documentclass{report}
\usepackage[portuges]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{url}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{nameref}

\usepackage{listings}
%LISTING - GENERAL
\lstset{
    basicstyle=\small,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    frame=tB,
    mathescape=true,
    escapeinside={(*@}{@*)},
    language=C,
    showstringspaces=false
}

\usepackage{xspace}

\parindent=0pt
\parskip=4pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\def\pe{\emph{Publicação Eletrónica}\xspace}

\def\titulo#1{\section{#1}}
\def\super#1{{\em Supervisor: #1}\\ }
\def\area#1{{\em \'{A}rea: #1}\\[0.2cm]}
\def\resumo{\underline{Resumo}:\\ }

\title{Processamento de Linguagens \\ MIEI (3º ano) \\~\\ \large Trabalho Prático nº 1 - Parte B (FLEX)\\ Relatório de Desenvolvimento \\~\\ Ano lectivo 16/17}
\author{João Pereira\\(A75273) \and João Martins\\(A68646) \and Manuel Freitas\\(A71646) }
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
O \textit{FLEX} é uma ferramenta extremamente poderosa e versátil que pode ser utilizada nos mais diversos domínios. Para se demonstrar isso, 
desenvolveu-se dois programas que fazem uso de analisadores léxicos gerados em \textit{FLEX}: o primeiro gera definições de funções \textit{C} a partir 
de \textit{templates}; o segundo é utilizado no contexto de um programa simples a ser executado por um \textit{robot}. Neste último, utiliza-se um 
analisador léxico para fazer \textit{parse} do resultado de um comando de \textit{Linux}, necessário ao funcionamento do \textit{robot}.
\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}
A análise de texto é uma das tarefas mais comuns dos programadores. No entanto, o desenvolvimento de analisadores léxicos com recurso a linguagens 
tradicionais tais como o \textit{C} ou o \textit{Java} é um processo demorado, relativamente complexo e muito susceptível a erros. Devido a isso e ao 
facto dos analisadores léxicos serem utilizados em praticamente todas as áreas às quais a informática é aplicada, torna-se útil o uso de ferramentas tais 
como o \textit{FLEX}, que permitem fácil e rapidamente especificar que padrões devem ser reconhecidos e as ações semânticas a realizar quando esses 
padrões forem encontrados.

A abordagem referida é extremamente vantajosa para quem programa porque muda o foco da implementação do mecanismo de deteção de padrões propriamente dito 
para os padrões que devem ser detetados e as ações a serem executadas. Para além disso, o tempo necessário para desenvolver um analisador léxico diminui 
significativamente, assim como a complexidade e tamanho do código necessário para o produzir. Outra vantagem de utilizar esta ferramenta é a facilidade 
de manutenção e extensão dos analisadores léxicos, uma vez que facilmente se adicionam ou mudam os padrões reconhecidos e as acções a eles associadas.

Por ser extremamente versátil, o \textit{FLEX} pode ser utilizado em vários domínios. Neste relatório, descreve-se o seu uso em dois domínios diferentes. 
No primeiro, construiu-se um processador de \textit{templates} para a linguagem de programção \textit{C}. No segundo, construiu-se um programa a ser 
executado por um \textit{robot} que utiliza a plataforma \textit{ROS}. Em particular, esse \textit{robot} faz uso do \textit{output} de um comando 
\textit{Linux} para determinar o seu comportamento. Esse \textit{output} tem de ser processado e é para esse fim que se utiliza o \textit{FLEX}.

\section*{Estrutura do Relatório}
O relatório encontra-se dividido em 4 capítulos:
\begin{enumerate}
    \item \nameref{intro} (o capítulo atual);
    \item \nameref{templates_c};
    \item \nameref{robot};
    \item \nameref{concl}.
\end{enumerate}
No capítulo~\ref{templates_c}, explica-se o processo e as decisões de desenvolvimento de um analisador léxico capaz de traduzir funções definidas por 
\textit{templates} para funções na síntaxe da linguagem de programação \textit{C}.

No capítulo~\ref{robot}, descreve-se a metodologia e as decisões de desenvolvimento de um analisador léxico 
utilizado por um programa em \textit{C++} a ser executado por um \textit{robot}, com base na \textit{framework} \textit{ROS (Robot Operating System)}. 
Embora o programa \textit{C++} referido seja relativamente simples, este está assente numa plataforma relativamente complexa (\textit{ROS}) pelo que 
apenas se descreve o analisador léxico utilizado pelo mesmo. No capítulo~\ref{concl}, termina-se o relatório com uma síntese do trabalho desenvolvido e 
com as respetivas conclusões.

\chapter{Templates em C} \label{templates_c}
\section{Análise e Especificação} \label{ae_af}
\subsection{Descrição Informal do Problema}
Por vezes, quando se programa em \textit{C} é necessário definir várias funções cujo comportamento é muito semelhante. Isso leva a grandes porções de 
código repetido que por sua vez tornam o código difícil de manter, dado que qualquer alteração numa função pode fazer com que seja necessário modificar 
as restantes. Uma possível solução para este problema passa por definir \textit{templates} para cada conjunto de funções que partilham o mesmo 
comportamento. Neste trabalho, definiu-se um formato de \textit{templates} para funções que devolvem \textit{strings} resultantes da concatenação de 
expressões passadas no corpo do \textit{template}.

Este exercício teve como objetivo a construção de um analisador léxico capaz de interpretar \textit{templates} embebidos em \textit{C}, de acordo com um 
formato especificado na próxima subsecção, e produzir as respetivas 
funções em \textit{C}.
\subsection{Formato dos Ficheiros de Input}
Os ficheiros de \textit{input} consistem em ficheiros de código \textit{C} que podem conter definições de funções através de \textit{templates} no 
formato:
\begin{verbatim}
Nome_da_Funcao = {{ corpo do template }}
\end{verbatim}
No corpo do \textit{template}, podem-se usar os seguintes padrões:
\begin{itemize}
  \item \texttt{ [\% variavel \%] } - quando este padrão é encontrado, regista-se \texttt{variavel} como um dos argumentos da função. O valor de \texttt{
  variavel} deverá constar no \textit{output} da função definida no \textit{template}, no local onde o padrão foi detetado;
  \item \texttt{ [\% MAP f c l \%]} - sempre que se encontra este padrão, regista-se \texttt{c} e \texttt{l} como argumentos da função definida pelo 
  \textit{template} do qual o MAP faz parte e acrescenta-se ao resultado dessa função o resultado da aplicação da função \texttt{f} a todos os elementos 
  da lista \texttt{l};
  \item \texttt{ [\% C expressao\_em\_c \%] } - quando este padrão é detetado, considera-se que \texttt{expressao\_em\_c} é uma expressão \textit{C} 
  cujo valor de retorno é do tipo \textit{string}. No resultado da função que está a ser definida irá constar o resultado da expressão em \textit{C}.
\end{itemize}
O texto de um \textit{template} que não concorde com nenhum destes padrões é considerado como sendo texto que deverá constar no resultado da função 
definida por esse \textit{template}, sem qualquer tipo de formatação.
\section{Compilação e Instalação}
Para se compilar o programa, deve-se invocar o comando \texttt{make} numa diretoria que contenha o ficheiro \textit{inline\_templates.fl} e a seguinte 
\textit{Makefile}:
\begin{verbatim}
v=inline_templates
$v: $v.fl
  flex --noyywrap $v.fl
  cc lex.yy.c -o $v
  rm lex.yy.c

install: $v
  mkdir -p ~/bin/
  mv $v ~/bin/
\end{verbatim}

Desta forma, é gerado o executável \texttt{inline\_templates}. Também se poderá utilizar o comando \texttt{make install} para instalar o programa 
numa pasta que conste, preferencialmente, na variável \texttt{PATH}. Por omissão, o executável é instalado na pasta \texttt{\textasciitilde/bin}.
\section{Utilização}
O programa deverá ser invocado da seguinte forma:
\begin{verbatim}
$ ./inline_templates < FICHEIRO_INPUT > FICHEIRO_OUTPUT
\end{verbatim}

O ficheiro \texttt{FICHEIRO\_INPUT} corresponde a código fonte \textit{C} com \textit{templates} embebidos e o ficheiro \texttt{FICHEIRO\_OUTPUT} 
corresponde ao código fonte em que as definições de funções com recurso a \textit{templates} encontradas em \texttt{FICHEIRO\_INPUT} foram substituídas 
por funções conforme a síntaxe da linguagem \textit{C}.
\subsection{Exemplo de Utilização}
Abaixo segue-se um exemplo de utilização do programa \textit{inline\_templates}.
\subsubsection{Input}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>

Fli={{<li> [% ele %] < /li>
}}

Fhtml={{<html>
<head><title>[% tit %]</title></head>
<body>
<h1>[% tit %]</h1>
<ul>[% MAP Fli comp items %]</ul>
</body>
</html>
}}

int main(){
  char * a[]={"expressoes regulares","parsers","compiladores"};
  printf("%s\n",Fhtml("Conteudo programático", 3, a));
}

\end{lstlisting}
\subsubsection{Output}
Passando o código \textit{C} com \textit{templates} embebidos acima apresentado para o comando \texttt{inline\_templates}, obtém-se o seguinte \textit{output}:
\begin{lstlisting}
#include <stdio.h>
#include <string.h>
  
char* Fli(char* ele){
   char BUF[10000];
   int j=0;
   int i;
   j += sprintf(BUF+j, "<li> ");
   j += sprintf(BUF+j, "%s", ele);
   j += sprintf(BUF+j, " < /li>\n");
   return strdup(BUF);
}

char* Fhtml(char* tit,int comp,char** items){
    char BUF[10000];
    int j=0;
    int i;
    j += sprintf(BUF+j, "<html>\n");
    j += sprintf(BUF+j, "  <head><title>");
    j += sprintf(BUF+j, "%s", tit);
    j += sprintf(BUF+j, "</title></head>\n");
    j += sprintf(BUF+j, "<body>\n");
    j += sprintf(BUF+j, "  <h1>");
    j += sprintf(BUF+j, "%s", tit);
    j += sprintf(BUF+j, "</h1>\n");
    j += sprintf(BUF+j, "  <ul>");
    for(i=0; i<comp; i++)
        j += sprintf(BUF+j, "%s", Fli(items[i]));
    j += sprintf(BUF+j, "</ul>\n");
    j += sprintf(BUF+j, "</body>\n");
    j += sprintf(BUF+j, "</html>\n");
    return strdup(BUF);
}

int main(){
    char * a[]={"expressoes regulares","parsers","compiladores"};
    printf("%s\n",Fhtml("Conteudo programático", 3, a));
}

\end{lstlisting}
\section{Concepção e Implementação da Resolução}
Passa-se agora a descrever o funcionamento do analisador léxico desenvolvido. O código na sua totalidade pode ser consultado no 
apêndice~\ref{cod_fich_template}.

Antes de quaisquer outras considerações, é necessário descrever o funcionamento geral do programa. Sempre que é detetado código \textit{C} ``normal'', 
i.e.: código que não ocorre dentro de um \textit{template}, este é imediatamente impresso no \texttt{stdout}. Quando é detetada a definição de uma 
função com recurso a um \textit{template}, o código dessa função é armazenado em \textit{buffers} por forma a facilitar a sua construção. Para o efeito, 
são utilizados três \textit{buffers}: um para o cabeçalho da função (\texttt{buf\_cabecalho\_func}), outro para o corpo (\texttt{buf\_corpo\_func}) e 
outro para armazenar uma linha da função de cada vez (\texttt{buf\_linha\_funcao}). Desta forma, o cabeçalho e o corpo das funções são construídos 
separadamente, evitando cálculos na enumeração dos parâmetros nos cabeçalhos das funções. Quando se chega ao fim da definição da função, o conteúdo dos 
\textit{buffers} acima referidos é formatado de forma a obedecer à sintaxe da linguagem \textit{C} e completar a definição da função, culminando numa 
função \textit{C} bem formada. Após o processo descrito, o código da função representada pelo \textit{template} é impresso no \texttt{stdout}.

O nome IDENT (definido como sendo a expressão regular \texttt{[a-zA-Z\_][a-zA-Z0-9\_]*}) descreve os identificadores que são reconhecidos. Cada 
identificador é constituído por uma letra ou \textit{underscore} seguido de 0 ou mais letras, números ou \textit{underscores}.

Quando o analisador léxico gerado começa a executar, este encontra-se no estado \texttt{INITIAL}. Neste estado, se se localizar o padrão 
\texttt{\{IDENT\}[:space:]*=[:space:]*\{\{}, isto é, caso se encontre um identificador seguido de 0 ou mais ocorrências de 
espaços e de um sinal de igual, possivelmente com espaços a seguir e, por fim, duas chavetas, considera-se que foi encontrada a definição de uma 
função através de um \textit{template}. Nestes casos, entra-se no contexto \texttt{decl\_funcao} e inicia-se a construção da função nos \textit{buffers}
acima referidos. Concretamente, coloca-se o tipo de retorno da função e o respetivo nome no \textit{buffer} do cabeçalho e a declaração de variáveis no 
\textit{buffer} que armazena o corpo da função. 

Seguidamente, se se encontrar o padrão \texttt{\textbackslash [\%[:space:]*}, entra-se no estado \texttt{var} e insere-se no corpo da função a instrução 
para imprimir o que foi lido da linha até ao momento. Caso contrário, o conteúdo lido é posto no \textit{buffer} de linha e quando a linha terminar, i.e. 
quando se encontrar um \textit{'\textbackslash n'}, insere-se no corpo da função uma instrução para imprimir tudo o que foi lido da mesma. Se 
eventualmente se encontrar aspas, será inserida no \textit{buffer} de linha a sequência de escape correspondente de forma a que quando esta for 
impressa, o símbolo impresso seja o pretendido.

No estado \texttt{var}, quando se encontra um identificador, pode-se suceder uma de três situações:
\begin{itemize}
  \item o identificador é \texttt{MAP}, pelo que identifica um mapeamento. Neste primeiro caso, entra-se no estado \texttt{map}. Quando um identificador 
    é encontrado neste estado, assume-se que este corresponde ao nome da função a aplicar aos elementos da lista e entra-se no estado 
    \texttt{map\_funcao\_lida}. Quando é encontrado outro identificador, considera-se que este corresponde ao nome da variável cujo valor corresponde ao 
    comprimento da lista e entra-se no estado \texttt{map\_comprimento\_lido}. Por fim, neste estado, quando se encontra um identificador considera-se
    que este corresponde ao nome da lista. Por esta altura, o mapeamento está completamente descrito e são colocadas no corpo da função 
    as instruções que adicionam ao output o resultado do mapeamento.
  \item o identificador é \texttt{C}, o que sinaliza uma expressão \textit{C} cujo tipo é \texttt{char *}. Neste caso, entra-se no estado
    \texttt{codigo\_c}. No estado \texttt{codigo\_c}, tudo o que se encontra até ao padrão \texttt{\%]} é considerado parte da expressão 
    \textit{C} e, por conseguinte, a instrução para adicionar ao resultado o valor da expressão \textit{C} é posta no corpo da função;
  \item nenhuma das anteriores, pelo que o identificador corresponde ao nome de uma variável. Neste último caso, insere-se no corpo da função
    a instrução para adicionar o valor da variável à \textit{string} devolvida. 
\end{itemize}
Quando o padrão \texttt{\%]} é encontrado nos estados \texttt{var}, \texttt{map\_comprimento\_lido} ou \texttt{codigo\_c}, considera-se
que as situações anteriormente descritas terminaram e volta-se ao estado \texttt{decl\_funcao}. 

Quando se encontra o padrão \texttt{\}\}}, insere-se a lista de parâmetros no cabeçalho da função e a instrução 
\\\texttt{return strdup(NOME\_DO\_BUFFER);} no corpo da função, em que NOME\_DO\_BUFFER corresponde ao nome escolhido para a variável
que contém o resultado da função obtida pelo analisador léxico. Depois disto, é impresso o cabeçalho e corpo da função, obtendo-se
a função em síntaxe \textit{C} correspondente à que estava definida no \textit{template}.

\textbf{Nota:} Sempre que é lido o nome de um argumento da função, verifica-se se o seu nome já foi usado anteriormente nessa função e, caso tenha
sido e os tipos não coincidam, o programa termina com um erro.

\chapter{Programa simples a ser executado por um Robot} \label{robot}
\section{Análise e Especificação} \label{ae_ros}
O \textit{ROS} é uma \textit{framework} que permite desenvolver programas para \textit{robots}. Esta \textit{framework} funciona como um sistema 
distribuído composto, essencialmente, por nodos e tópicos. Os tópicos correspondem a filas de mensagens, enquanto que 
os nodos correspondem a executáveis que podem ler ou publicar em tópicos. Sugere-se aos leitores mais interessados que consultem o \textit{website}
\url{http://wiki.ros.org/ROS/Tutorials}. 
\subsection{Descrição Informal do Problema}
Para se exemplificar as funcionalidades de um \textit{robot}, decidiu-se construir um programa que faz com que o mesmo se desloque aleatoriamente
enquanto que emite \textit{beeps}. A frequência desses \textit{beeps} é ditada pela intensidade do sinal \textit{Wi-Fi} da rede \textit{eduroam}.
Quanto mais intenso for o sinal da rede, maior frequência terão os \textit{beeps}. Através do comando \texttt{iwlist scan INTERFACE}, consegue-se
obter informações sobre as redes detetadas. Pretende-se então construir um analisador do \textit{output} deste comando, para ser executado por um
nodo do programa.
\subsection{Formato do \textit{input}} \label{form_inp_ros}
O \textit{input} do analisador léxico consiste no \textit{output} do comando \texttt{iwlist scan INTERFACE}. Abaixo, pode-se consultar um exemplo do 
\textit{output} deste comando:
\begin{lstlisting}
          Cell 01 - Address: 00:60:1D:01:23:45
                    Channel:1
                    Frequency:2.412 GHz (Channel 1)
                    Quality=70/70  Signal level=0 dBm  
                    Encryption key:on
                    ESSID:"MyNetwork"
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s
                    9 Mb/s; 12 Mb/s; 18 Mb/s
                    Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s
                    Mode:Ad-Hoc
                    Extra:tsf=0000000000000000
                    Extra: Last beacon: 12980ms ago
                    IE: Unknown: 000473313030
                    IE: Unknown: 010882040B160C121824
\end{lstlisting}
\textbf{Nota}: no exemplo acima só foi encontrada uma rede. Se tivessem sido descobertas mais redes, seria apresentada uma listagem de informações como
a mostrada acima, para cada rede encontrada.
\section{Concepção e Implementação da Resolução}
Dado que as API's existentes da plataforma \textit{ROS} estão escritas em \textit{C++}, utilizou-se a opção \texttt{\%option c++} para gerar um 
analisador nesta linguagem a partir do \textit{FLEX}. A classe \texttt{wifi\_info} é um tipo de mensagens que pode ser publicado num tópico.
Esta classe armazena a seguinte informação acerca de uma rede \textit{Wi-Fi}: 
\begin{itemize}
  \item endereço do \textit{Access Point} - campo \texttt{address};
  \item canal em que a rede opera - campo \texttt{channel};
  \item ESSID da rede - campo \texttt{essid}; 
  \item qualidade do sinal - campo \texttt{quality};
  \item força do sinal em dBm - campo \texttt{signal\_level\_dBm};
\end{itemize}
Para cada rede encontrada, pretende-se criar uma mensagem com as informações referidas acima para ser posteriormente publicada num tópico.
O funcionamento deste analisador léxico é significativamente mais simples do que o que foi apresentado anteriormente. No entanto, existem alguns
detalhes que o grupo quer ressalvar. Para cada um dos campos da rede referidos acima existe, no \textit{output}, um padrão no formato 
\texttt{NOME\_CAMPO: VALOR} excepto no campo \texttt{Address}, dado que existe um espaço a seguir a \textit{':'}. A acção correspondente
a cada um dos padrões consiste em retirar o nome do campo, deixando apenas o valor, e inserir o valor no campo correto da mensagem.

Dado que o ESSID é o último campo de interesse apresentado no \textit{output} do comando, quando este valor é lido, retorna-se da função
devolvendo o valor \texttt{NETWORK\_READ}. Por essa razão, em cada invocação da função \texttt{yylex} lê-se, no máximo, as informações de uma
rede. Quando se chega ao final do ficheiro, retorna-se o valor \texttt{END} que indica que o \textit{output} do comando já foi completamente 
processado.
\chapter{Conclusão} \label{concl}
O grupo considera que o \textit{FLEX} foi a ferramenta adequada para os trabalhos discutidos, sobretudo devido à rapidez com
que permite desenvolver analisadores léxicos e à sua grande versatilidade e poder expressivo. No entanto, o grupo constatou que esta 
ferramenta apresenta algumas falhas que obrigam à adoção de soluções pouco elegantes, principalmente no que toca à integração da mesma
com a linguagem \textit{C++}. Além disso, o grupo é da opinião que as extensões à notação das linguagens regulares como as que existem noutros 
programas (por exemplo, a possibilidade de usar expressões regulares de \textit{PERL} no programa \textit{grep}) seriam uma boa adição ao \textit{FLEX},
uma vez que aumentariam ainda mais o seu poder expressivo. Não obstante disso, as dificuldades encontradas foram sempre superadas e os resultados obtidos
foram os esperados. Por esse motivo, o grupo considera que fez um bom trabalho, tendo também demonstrado que o \textit{FLEX} pode ser aplicado em vários 
domínios que não os abordados nas aulas (neste caso, mostrou-se o uso do mesmo em robótica). Acima de tudo, ficou patente a utilidade desta ferramenta e 
a ubiquidade das tarefas de análise léxica.
\appendix

\chapter{Código dos Programas} 

\section{Conteúdo do ficheiro \texttt{inline\_templates.fl}} \label{cod_fich_template}
\begin{lstlisting}
IDENT         [a-zA-Z_][a-zA-Z0-9_]*

%x decl_funcao
%x nome_funcao_encontrado
%x dentro_aspas_funcao
%x map
%x map_funcao_lida
%x map_comprimento_lido
%x var
%x codigo_c

%top{
    #include <stdio.h>
    #include <string.h>
    #include <ctype.h>

    #define TAMANHO_BUFFER 10000
    #define TAMANHO_MAX_CABECALHO 4096
    #define TAMANHO_MAX_CORPO 20000
    #define TAMANHO_MAX_LINHA_FUNCAO 4096
    #define MAX_VARIAVEIS 1000

    /* usa-se char para armazenar informação do tipo de uma var de forma a poupar memoria */
    typedef char TIPO;
    #define INT 0
    #define STRING 1
    #define LISTA_STRINGS 2 

    char buf_corpo_func[TAMANHO_MAX_CORPO];
    char buf_cabecalho_func[TAMANHO_MAX_CABECALHO];
    char buf_linha_funcao[TAMANHO_MAX_LINHA_FUNCAO];
    char* nomes_variaveis[MAX_VARIAVEIS]; 
    TIPO tipos_variaveis[MAX_VARIAVEIS];
    
    /* vars para leitura de mapas */
    char* nome_funcao;
    char* var_comprimento;
    char* nome_lista;
  
    int pos_buf_cabecalho = 0;
    int pos_buf_corpo = 0;
    int pos_buf_linha = 0;
    int pos_variaveis = 0;
    int insereVar(char* nome, TIPO tipo);

    /* vars usadas no programa gerado */
    #define NOME_BUFF "BUF"
    #define NOME_VAR1 "j"
    #define NOME_VAR2 "i"

    /* macros uteis para simplificar expressoes */
    #define ADICIONA_CABECALHO(...) pos_buf_cabecalho += sprintf(buf_cabecalho_func + pos_buf_cabecalho, __VA_ARGS__)
    #define ADICIONA_CORPO(...) pos_buf_corpo += sprintf(buf_corpo_func + pos_buf_corpo, __VA_ARGS__);
}

%%

<INITIAL>{IDENT}[:space:]*=[:space:]*\{\{        {
  /* Encontrou um template de uma funcao */
    int i, j;
    BEGIN(decl_funcao);
    char nome[128]; 
    for(i = 0, j=0; !isspace(yytext[i]) && yytext[i] != '='; i++)
        nome[j++] = yytext[i]; 
    nome[j] = '\0';
    pos_buf_cabecalho = pos_buf_corpo = pos_buf_linha = pos_variaveis = 0;
    ADICIONA_CABECALHO("char* %s(", nome);
    ADICIONA_CORPO("\tchar "NOME_BUFF"[%d];\n\tint "NOME_VAR1"=0;\n\tint "NOME_VAR2";\n", TAMANHO_BUFFER);
}

<decl_funcao>\[%[:space:]*        { 
    BEGIN(var); 
    if(pos_buf_linha != 0) {
      buf_linha_funcao[pos_buf_linha++] = '\0';
      ADICIONA_CORPO("\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\");\n", buf_linha_funcao);
    }
    pos_buf_linha = 0;
}
  

<decl_funcao>\"        {
    buf_linha_funcao[pos_buf_linha++] = '\\';
    buf_linha_funcao[pos_buf_linha++] = '\"';
}

<decl_funcao>.        {
    buf_linha_funcao[pos_buf_linha++] = yytext[0];
}

<decl_funcao>\n        {
    buf_linha_funcao[pos_buf_linha++] = '\\';
    buf_linha_funcao[pos_buf_linha++] = 'n';
    buf_linha_funcao[pos_buf_linha++] = '\0';
    ADICIONA_CORPO("\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\");\n", buf_linha_funcao);
    pos_buf_linha = 0; 
}

<var,map_comprimento_lido,codigo_c>[:space:]*%\]        { BEGIN(decl_funcao); }

<var>{IDENT}        {
    if(!strcmp(yytext, "MAP")){
      BEGIN(map);
    } else if(!strcmp(yytext, "C")){
      BEGIN(codigo_c);
    } else {
      insereVar(yytext, STRING);
      ADICIONA_CORPO("\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\", %s);\n", "%%s", yytext);
    }
}

<map>{IDENT}        {
    BEGIN(map_funcao_lida);
    nome_funcao = strdup(yytext);
}

<map_funcao_lida>{IDENT}        {
    BEGIN(map_comprimento_lido);
    var_comprimento = strdup(yytext);
    insereVar(var_comprimento, INT);
}

<map_comprimento_lido>{IDENT}        {
    nome_lista = yytext; 
    insereVar(nome_lista, LISTA_STRINGS);
    
    ADICIONA_CORPO("\tfor("NOME_VAR2"=0; "NOME_VAR2"<%s; "NOME_VAR2"++)\n", var_comprimento);
    ADICIONA_CORPO("\t\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\", %s(%s["NOME_VAR2"]));\n", "%%s", nome_funcao, nome_lista);
    free(nome_funcao);
    free(var_comprimento);
}

<map_funcao_lida>.        {}

<codigo_c>.*/%\]        {
    ADICIONA_CORPO("\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\",%s);\n", "%%s", yytext);
}

<decl_funcao>\}\}        { 
    BEGIN(INITIAL);

    // completa cabecalho funcao
    int i;
    char* tipo = NULL;
    for(i=0; i < pos_variaveis; i++){
      switch(tipos_variaveis[i]){
        case INT: tipo = "int"; break;
        case STRING: tipo = "char*"; break;
        case LISTA_STRINGS: tipo = "char**"; break;
      }
      ADICIONA_CABECALHO("%s %s,",tipo,nomes_variaveis[i] );
      free(nomes_variaveis[i]);
    }
         
    switch(buf_cabecalho_func[pos_buf_cabecalho-1]){
      case '(': buf_cabecalho_func[pos_buf_cabecalho++] = ')';
        break;
      case ',': buf_cabecalho_func[pos_buf_cabecalho-1] = ')';
        break;
    }
    buf_cabecalho_func[pos_buf_cabecalho++] = '{'; 
    buf_cabecalho_func[pos_buf_cabecalho++] = '\n'; 
    buf_cabecalho_func[pos_buf_cabecalho] = '\0'; 

    // completa corpo funcao
    ADICIONA_CORPO("\treturn strdup("NOME_BUFF");\n}");

    // imprime declaracao funcao
    printf("\n%s", buf_cabecalho_func);
    printf(buf_corpo_func);
}

%%

int insereVar(char* nome, TIPO tipo){
  int i, found=0;
  for(i=0; i < pos_variaveis; i++){
    if(!strcmp(nome,nomes_variaveis[i])){
      found = 1;
      if(tipos_variaveis[i] != tipo){
        fprintf(stderr, "ERRO: Está a usar variáveis iguais de tipos diferentes\n");
        exit(1);
      }
      break;
    } 
  }
  if(!found){
    nomes_variaveis[pos_variaveis] = strdup(nome);
    tipos_variaveis[pos_variaveis++] = tipo;
  }
  return found;
}

int main(){
  yylex();
}
\end{lstlisting}
\newpage

\section{Excerto do ficheiro \texttt{wifi\_info\_collector.fl}} \label{cod_fich_ros}
Devido ao tamanho do programa e ao facto da maior parte do código estar fora do âmbito da Unidade Curricular, optou-se por apresentar apenas 
o analisador léxico. No entanto, o ficheiro na sua totalidade foi disponibilizado online por um dos elementos do grupo e pode ser consultado em 
\url{https://github.com/jcp19/ros_packages/blob/master/wifi_info/src/wifi_info_collector.l}.
\begin{lstlisting}[language=C++]

%option c++

%{
#include "ros/ros.h"
#include "wifi_info/wifi.h"
#include <string>
#include <cstring>
#include <sstream>
#include <iostream>
#include <stdexcept>
#include <stdio.h>

wifi_info::wifi * info;

// return values:
#define NETWORK_READ 1
#define END 2

%}

%%
Cell	{ 
          ;
        }

Address:[[:space:]]([0-9A-F]+:)+[0-9A-F]+ {
			std::string s(yytext);
			std::string address = s.erase(0, strlen("Address: "));
			info->address = address;
		}
Channel:[0-9]+ {
		std::string s(yytext);
		std::string schannel = s.erase(0, strlen("Channel:"));
		int channel = std::stoi(schannel);
		info->channel = channel;
}

ESSID:\"[^\"]+\" {
		std::string s(yytext);
		std::string essid = s.erase(0, strlen("ESSID:\""));
		essid.erase(essid.size()-1, essid.size());
		info->essid = essid;
		return NETWORK_READ;
}

Quality=[0-9]+\/[0-9]+ {
		std::string q(yytext);
		q.erase(0, strlen("Quality="));
		info->quality = q;
	}

Signal[[:space:]]level=-[0-9]+ {
		std::string sl(yytext);
		sl.erase(0, strlen("Signal level="));
		info->signal_level_dBm = std::stoi(sl);
}	


<<EOF>> { return END; }
.|\n {;}
%%
\end{lstlisting}

\chapter{Código \textit{C} com \textit{templates} embebidos e \textit{output} do programa \texttt{inline\_templates}}
Neste capítulo apresenta-se exemplos de código \textit{C} com \textit{templates} embebidos e, para cada exemplo, apresenta-se o resultado
de o passar para o programa \texttt{inline\_templates}.

\section{Exemplo com \textit{templates} que contêm variáveis e \textit{maps}}
Abaixo, segue-se um exemplo de código \textit{C} com \textit{templates} disponibilizado no enunciado. Os \textit{templates} apresentam variáveis 
e \textit{maps}:
\begin{lstlisting}
#include <stdio.h>
#include <string.h>

Fli={{<li> [% ele %] < /li>
}}

Fhtml={{<html>
  <head><title>[% tit %]</title></head>
<body>
  <h1>[% tit %]</h1>
  <ul>[% MAP Fli comp items %]</ul>
</body>
</html>
}}

int main(){
  char * a[]={"expressoes regulares","parsers","compiladores"};
  printf("%s\n",Fhtml("Conteudo programático", 3, a));
}
\end{lstlisting}

Para o exemplo apresentado, o programa \texttt{inline\_templates} produz o seguinte código \textit{C}:
\begin{lstlisting}
#include <stdio.h>
#include <string.h>

  
char* Fli(char* ele){
  char BUF[10000];
  int j=0;
  int i;
  j += sprintf(BUF+j, "<li> ");
  j += sprintf(BUF+j, "%s", ele);
  j += sprintf(BUF+j, " < /li>\n");
  return strdup(BUF);
}

        
char* Fhtml(char* tit,int comp,char** items){
  char BUF[10000];
  int j=0;
  int i;
  j += sprintf(BUF+j, "<html>\n");
  j += sprintf(BUF+j, "  <head><title>");
  j += sprintf(BUF+j, "%s", tit);
  j += sprintf(BUF+j, "</title></head>\n");
  j += sprintf(BUF+j, "<body>\n");
  j += sprintf(BUF+j, "  <h1>");
  j += sprintf(BUF+j, "%s", tit);
  j += sprintf(BUF+j, "</h1>\n");
  j += sprintf(BUF+j, "  <ul>");
  for(i=0; i<comp; i++)
    j += sprintf(BUF+j, "%s", Fli(items[i]));
  j += sprintf(BUF+j, "</ul>\n");
  j += sprintf(BUF+j, "</body>\n");
  j += sprintf(BUF+j, "</html>\n");
  return strdup(BUF);
}

int main(){
  char * a[]={"expressoes regulares","parsers","compiladores"};
  printf("%s\n",Fhtml("Conteudo programático", 3, a));
}
\end{lstlisting}

\section{Exemplo de código \textit{C} com um \textit{template} inválido}
O exemplo que se segue é bastante parecido com o anterior, no entanto, ao contrário do exemplo anterior, é inválido uma vez que a variável \texttt{tit}, 
inicialmente usada na linha 8 como sendo do tipo \textit{string}, é posteriormente utilizada na linha 11 como se fosse do tipo inteiro, ao ser passada 
como comprimento da lista de um MAP.

\begin{lstlisting}
#include <stdio.h>
#include <string.h>

Fli={{<li> [% ele %] < /li>
}}

Fhtml={{<html>
  <head><title>[% tit %]</title></head>
<body>
  <h1>[% tit %]</h1>
  <ul>[% MAP Fli tit items %]</ul>
</body>
</html>
}}

int main(){
  char * a[]={"expressoes regulares","parsers","compiladores"};
  printf("%s\n",Fhtml("Conteudo programático", 3, a));
}
\end{lstlisting}

Como este exemplo é inválido (pelas razões mencionadas no parágrafo anterior), quando se passa o código apresentado para o programa 
\texttt{inline\_templates}, o resultado é:

\begin{lstlisting}
#include <stdio.h>
#include <string.h>

  
char* Fli(char* ele){
  char BUF[10000];
  int j=0;
  int i;
  j += sprintf(BUF+j, "<li> ");
  j += sprintf(BUF+j, "%s", ele);
  j += sprintf(BUF+j, " < /li>\n");
  return strdup(BUF);
}

ERRO: Está a usar variáveis iguais de tipos diferentes
\end{lstlisting}

Como se pode observar, foi gerado código \textit{C} válido para a função \texttt{Fli}, uma vez que o respetivo \textit{template} é válido. No entanto, 
o \textit{template} da função \texttt{Fhtml} era inválido, portanto em vez do corpo da mesma, foi impressa a mensagem
``ERRO: Está a usar variáveis iguais de tipos diferentes''.

\section{Exemplo de \textit{template} com uma expressão \textit{C}}

Um exemplo de um \textit{template} com uma expressão \textit{C} é:
\begin{lstlisting}
Fli={{<li> [% ele %] </li>
<codigo> [% C strdup(X) %] </codigo>
}}
\end{lstlisting}

Passando o código apresentado para o programa \texttt{inline\_templates}, obtém-se o seguinte \textit{output}:
\begin{lstlisting}
char* Fli(char* ele){
  char BUF[10000];
  int j=0;
  int i;
  j += sprintf(BUF+j, "<li> ");
  j += sprintf(BUF+j, "%s", ele);
  j += sprintf(BUF+j, " </li>\n");
  j += sprintf(BUF+j, "<codigo> ");
  j += sprintf(BUF+j, "%s", strdup(X) );
  j += sprintf(BUF+j, " </codigo>\n");
  return strdup(BUF);
}
\end{lstlisting}

\section{Exemplo de código \textit{C} com um \textit{template} para gerar o código \textit{boilerplate} de uma página HTML}

Um exemplo de um \textit{template} de uma função \textit{C} que produz o chamado código \textit{boilerplate} de uma página HTML é:
\begin{lstlisting}
BoilerPlate={{<html>
  <head>
    <meta charset="UTF-8">
    <title> [% title %] </title>
    <meta name="description" content="[% description %]">
  </head>
  <body>
  </body>
}}
\end{lstlisting}

Passando o código apresentado para o programa \texttt{inline\_templates}, obtém-se como resultado a função:
\begin{lstlisting}
char* BoilerPlate(char* title,char* description){
    char BUF[10000];
    int j=0;
    int i;
    j += sprintf(BUF+j, "<html>\n");
    j += sprintf(BUF+j, "  <head>\n");
    j += sprintf(BUF+j, "    <meta charset=\"UTF-8\">\n");
    j += sprintf(BUF+j, "    <title> ");
    j += sprintf(BUF+j, "%s", title);
    j += sprintf(BUF+j, " </title>\n");
    j += sprintf(BUF+j, "    <meta name=\"description\" content=\"");
    j += sprintf(BUF+j, "%s", description);
    j += sprintf(BUF+j, "\">\n");
    j += sprintf(BUF+j, "  </head>\n");
    j += sprintf(BUF+j, "  <body>\n");
    j += sprintf(BUF+j, "\n");
    return strdup(BUF);
}
\end{lstlisting}

\nocite{*}
\bibliographystyle{ieeetr}
\bibliography{referencias_bibliograficas_tp1b}

\end{document} 
