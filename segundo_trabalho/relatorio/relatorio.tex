\documentclass{report}
\usepackage[portuges]{babel}
\usepackage[latin1]{inputenc}

\usepackage{url}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{nameref}

\usepackage{listings}
%LISTING - GENERAL
\lstset{
    basicstyle=\small,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    frame=tB,
    mathescape=true,
    escapeinside={(*@}{@*)},
    language=C
}

\usepackage{xspace}

\parindent=0pt
\parskip=4pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\def\pe{\emph{Publicação Eletrónica}\xspace}

\def\titulo#1{\section{#1}}
\def\super#1{{\em Supervisor: #1}\\ }
\def\area#1{{\em \'{A}rea: #1}\\[0.2cm]}
\def\resumo{\underline{Resumo}:\\ }

\title{Processamento de Linguagens \\ MIEI (3º ano) \\~\\ \large Trabalho Prático nº 1 - Parte B (FLEX)\\ Relatório de Desenvolvimento \\~\\ Ano lectivo 16/17}
\author{João Pereira\\(A75273) \and João Martins\\(A68646) \and Manuel Freitas\\(A71646) }
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
O \textit{FLEX} é uma ferramenta extremamente poderosa e versátil que pode ser utilizada nos mais diversos domínios. Para demonstrar isto,
desenvolveram-se dois programas que fazem uso de analisadores léxicos gerados em \textit{FLEX}: o primeiro programa gera definições 
de funções \textit{C} a partir de templates de funções e o segundo é utilizado no contexto de um programa simples a ser executado por 
  um \textit{robot}. Neste último exemplo, utiliza-se um analisador léxico para fazer \textit{parse} do resultado de um comando de 
  \textit{Linux}, necessário ao funcionamento do \textit{robot}.
\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}
A análise de texto é uma das tarefas mais comuns dos programadores. No entanto, o desenvolvimento de analisadores léxicos com recurso
a linguagens tradicionais tais como C ou Java é um processo demorado e relativamente complexo, muito susceptível a erros. 
Devido a isto e ao facto dos analisadores léxicos serem utilizados em praticamente todas as áreas em que a informática 
é aplicada, torna-se útil o uso de ferramentas tais como o \textit{FLEX} que permitem fácil e rapidamente especificar que padrões 
devem ser reconhecidos e que ações devem ser realizadas quando esses mesmos padrões são encontrados.

Esta abordagem é extremamente vantajosa para os programadores porque muda o foco da implementação do mecanismo de deteção de 
padrões propriamente dito para os padrões que devem ser detetados e as ações a serem executadas. Para além disso, o tempo necessário 
para construir um analisador léxico diminui significativamente, assim como a complexidade e tamanho do código necessário para gerar o 
analisador.
Outra vantagem de utilizar esta ferramenta é a facilidade de manutenção e extensão de analisadores, uma vez que facilmente se adicionam ou mudam
os padrões reconhecidos e as acções associadas a eles.

Por ser extremamente versátil, esta ferramenta pode ser utilizada em vários domínios. Este relatório descreve o uso do 
\textit{FLEX} em dois domínios diferentes. No primeiro caso, construiu-se um processador de \textit{templates} para a linguagem de
programção \textit{C}. No segundo caso, construiu-se um programa a ser executado por um \textit{robot} que utiliza a plataforma \textit{ROS}.
Em particular, esse \textit{robot} faz uso do \textit{output} de um comando \textit{Linux} para determinar o seu comportamento. Esse resultado tem
de ser processado e é para esse fim que se utiliza o \textit{FLEX}.

\section*{Estrutura do Relatório}
O relatório encontra-se dividido em 4 capítulos:
\begin{enumerate}
    \item \nameref{intro} (o capítulo atual);
    \item \nameref{templates_c};
    \item \nameref{robot};
    \item \nameref{concl}.
\end{enumerate}
No capítulo~\ref{templates_c}, explica-se o processo e as decisões de desenvolvimento de um analisador léxico capaz de traduzir funções
definidas por \textit{templates} em funções na síntaxe da linguagem de programação \textit{C}.

No capítulo~\ref{robot}, descreve-se a metodologia e as decisões de desenvolvimento de um analisador léxico 
utilizado por um programa em \textit{C++} a ser executado num robot,
com base na framework \textit{ROS (Robot Operating System)}. Embora esse seja um programa 
relativamente simples, está assente numa plataforma relativamente complexa (\textit{ROS}) pelo que apenas se descreve o analisador léxico
utilizado pelo mesmo.
No capítulo~\ref{concl}, termina-se o relatório com uma síntese do trabalho desenvolvido e com as conclusões do mesmo.

\chapter{Templates em C} \label{templates_c}

\section{Análise e Especificação} \label{ae_af}

\subsection{Descrição Informal do Problema}
\newpage
\subsection{Formato do Ficheiro de Input}
\section{Utilização}
\subsection{Exemplos de Utilização}
\section{Concepção e Implementação da Resolução}
\subsection{Codificação}
\subsection{Testes}
\chapter{Desenvolvimento de programa simples para robot com parsing de resultados} \label{robot}
\section{Análise e Especificação} \label{ae_vv}
\subsection{Descrição Informal do Problema}
\subsection{Especificação dos Requisitos} \label{er_vv}
\subsection{Formato do \textit{input}} \label{form_inp_vv}
\section{Utilização}
\subsection{Exemplos de Utilização}
Referir que os resultados de utilização foram obtidos empiricamente
\section{Concepção e Implementação da Resolução}

\subsection{Codificação} \label{cod_af}
\subsection{Testes}
\chapter{Conclusão} \label{concl}
\appendix

\chapter{Código dos Programas}

\section{Conteúdo do ficheiro \texttt{inline\_templates.fl}} \label{cod_fich_template}
\begin{lstlisting}
IDENT         [a-zA-Z_][a-zA-Z0-9_]*

%x decl_funcao
%x nome_funcao_encontrado
%x dentro_aspas_funcao
%x map
%x map_funcao_lida
%x map_comprimento_lido
%x var
%x codigo_c

%top{
    #include <stdio.h>
    #include <string.h>
    #define TAMANHO_BUFFER 10000
    #define TAMANHO_MAX_CABECALHO 4096
    #define TAMANHO_MAX_CORPO 20000
    #define TAMANHO_MAX_LINHA_FUNCAO
    #define MAX_VARIAVEIS 1000

    /* usa-se char para armazenar informação do tipo de uma var de forma a poupar memoria */
    typedef char TIPO;
    #define INT 0
    #define STRING 1
    #define LISTA_STRINGS 2 

    char buf_corpo_func[TAMANHO_MAX_CORPO];
    char buf_cabecalho_func[TAMANHO_MAX_CORPO];
    char buf_linha_funcao[TAMANHO_MAX_LINHA_FUNCAO];
    char* nomes_variaveis[MAX_VARIAVEIS]; 
    TIPO tipos_variaveis[MAX_VARIAVEIS];
                                                                        
    /* vars para leitura de mapas */
    char* nome_funcao;
    char* var_comprimento;
    char* nome_lista;
                                                                                          
    int pos_buf_cabecalho = 0;
    int pos_buf_corpo = 0;
    int pos_buf_linha = 0;
    int pos_variaveis = 0;
    int insereVar(char* nome, TIPO tipo);

    /* vars usadas no programa gerado */
    #define NOME_BUFF "BUF"
    #define NOME_VAR1 "j"
    #define NOME_VAR2 "i"

    /* macros uteis para simplificar expressoes */
    #define ADICIONA_CABECALHO(...) pos_buf_cabecalho += sprintf(buf_cabecalho_func + pos_buf_cabecalho, __VA_ARGS__)
    #define ADICIONA_CORPO(...) pos_buf_corpo += sprintf(buf_corpo_func + pos_buf_corpo, __VA_ARGS__);
}

%%

<INITIAL>{IDENT}/[:space:]*=[:space:]*\{\{        {
/* Encontrou um template de uma funcao */
    BEGIN(nome_funcao_encontrado);
    pos_buf_cabecalho = pos_buf_corpo = pos_buf_linha = pos_variaveis = 0;
    ADICIONA_CABECALHO("char* %s(", yytext);
    ADICIONA_CORPO("\tchar "NOME_BUFF"[%d];\n\tint "NOME_VAR1"=0;\n\tint "NOME_VAR2";\n", TAMANHO_BUFFER);
}

<nome_funcao_encontrado>[:space:]*=[:space:]*\{\{        { BEGIN(decl_funcao); }

<decl_funcao>\[%[:space:]*        { 
    BEGIN(var); 
    if(pos_buf_linha != 0) {
        buf_linha_funcao[pos_buf_linha++] = '\0';
        ADICIONA_CORPO("\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\");\n", buf_linha_funcao);
    }
    pos_buf_linha = 0;
}

<decl_funcao>\"        {
    /* no relatorio, explicar convençao das chavetas */
    buf_linha_funcao[pos_buf_linha++] = '\\';
    buf_linha_funcao[pos_buf_linha++] = '\"';
}

<decl_funcao>.        {
    buf_linha_funcao[pos_buf_linha++] = yytext[0];
}

<decl_funcao>\n        {
    buf_linha_funcao[pos_buf_linha++] = '\\';
    buf_linha_funcao[pos_buf_linha++] = 'n';
    buf_linha_funcao[pos_buf_linha++] = '\0';
    ADICIONA_CORPO("\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\");\n", buf_linha_funcao);
    pos_buf_linha = 0; 
}

<var,map_comprimento_lido,codigo_c>[:space:]*%\]        { BEGIN(decl_funcao); }

<var>{IDENT}        {
    if(!strcmp(yytext, "MAP")){
        BEGIN(map);
    } else if(!strcmp(yytext, "C")){
        BEGIN(codigo_c);
    } else {
        insereVar(yytext, STRING);
        ADICIONA_CORPO("\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\", %s);\n", "%%s", yytext);
    }
}

<map>{IDENT}        {
    BEGIN(map_funcao_lida);
    nome_funcao = strdup(yytext);
}

<map_funcao_lida>{IDENT}        {
    BEGIN(map_comprimento_lido);
    var_comprimento = strdup(yytext);
    insereVar(var_comprimento, INT);
}

<map_comprimento_lido>{IDENT}        {
    nome_lista = yytext; 
    insereVar(nome_lista, LISTA_STRINGS);
    ADICIONA_CORPO("\tfor("NOME_VAR2"=0; "NOME_VAR2"<%s; "NOME_VAR2"++)\n", var_comprimento);
    ADICIONA_CORPO("\t\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\", %s(%s["NOME_VAR2"]));\n", "%%s", nome_funcao, nome_lista);
    free(nome_funcao);
    free(var_comprimento);
}

<map_funcao_lida>.        {}

<codigo_c>.*/%\]        {
    ADICIONA_CORPO("\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\",%s);\n", "%%s", yytext);
}

<decl_funcao>\}\}        { 
    BEGIN(INITIAL);

    // completa cabecalho funcao
    int i;
    char* tipo = NULL;
    for(i=0; i < pos_variaveis; i++){
        switch(tipos_variaveis[i]){
            case INT: tipo = "int"; break;
            case STRING: tipo = "char*"; break;
            case LISTA_STRINGS: tipo = "char**"; break;
        }
        ADICIONA_CABECALHO("%s %s,",tipo,nomes_variaveis[i] );
        free(nomes_variaveis[i]);
     }

     switch(buf_cabecalho_func[pos_buf_cabecalho-1]){
         case '(': buf_cabecalho_func[pos_buf_cabecalho++] = ')';
                   break;
         case ',': buf_cabecalho_func[pos_buf_cabecalho-1] = ')';
                   break;
     }

     buf_cabecalho_func[pos_buf_cabecalho++] = '{'; 
     buf_cabecalho_func[pos_buf_cabecalho++] = '\n'; 
     buf_cabecalho_func[pos_buf_cabecalho] = '\0'; 

     // completa corpo funcao
     ADICIONA_CORPO("\treturn strdup("NOME_BUFF");\n}");

     // imprime declaracao funcao
     printf("\n%s", buf_cabecalho_func);
     printf(buf_corpo_func);
}

%%

int insereVar(char* nome, TIPO tipo){
    int i, found=0;
    for(i=0; i < pos_variaveis; i++){
        if(!strcmp(nome,nomes_variaveis[i])){
            found = 1;
            if(tipos_variaveis[i] != tipo){
                fprintf(stderr, "ERRO: Está a usar variáveis iguais de tipos diferentes\n");
                exit(1);
            }
            break;
        } 
    }

    if(!found){
        nomes_variaveis[pos_variaveis] = strdup(nome);
        tipos_variaveis[pos_variaveis++] = tipo;
    }
    return found;
}

int main(){
    yylex();
}

\end{lstlisting}

\section{Conteúdo do ficheiro \texttt{.fl}} \label{cod_fich_vv}
\begin{verbatim}

\end{verbatim}

\chapter{\textit{Input} e \textit{output} dos exemplos/testes}

\section{Templates em C}

\subsection{Conteúdo do ficheiro \texttt{input.c}} \label{hendrix_in}
\begin{lstlisting}[language=XML]
\end{lstlisting}


\nocite{*}
\bibliographystyle{ieeetr}
\bibliography{referenciasWeb}

\end{document} 
