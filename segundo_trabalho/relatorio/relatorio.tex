\documentclass{report}
\usepackage[portuges]{babel}
\usepackage[latin1]{inputenc}

\usepackage{url}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{nameref}

\usepackage{listings}
%LISTING - GENERAL
\lstset{
    basicstyle=\small,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    frame=tB,
    mathescape=true,
    escapeinside={(*@}{@*)},
    language=C,
    showstringspaces=false
}

\usepackage{xspace}

\parindent=0pt
\parskip=4pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\def\pe{\emph{Publicação Eletrónica}\xspace}

\def\titulo#1{\section{#1}}
\def\super#1{{\em Supervisor: #1}\\ }
\def\area#1{{\em \'{A}rea: #1}\\[0.2cm]}
\def\resumo{\underline{Resumo}:\\ }

\title{Processamento de Linguagens \\ MIEI (3º ano) \\~\\ \large Trabalho Prático nº 1 - Parte B (FLEX)\\ Relatório de Desenvolvimento \\~\\ Ano lectivo 16/17}
\author{João Pereira\\(A75273) \and João Martins\\(A68646) \and Manuel Freitas\\(A71646) }
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
O \textit{FLEX} é uma ferramenta extremamente poderosa e versátil que pode ser utilizada nos mais diversos domínios. Para demonstrar isto,
desenvolveram-se dois programas que fazem uso de analisadores léxicos gerados em \textit{FLEX}: o primeiro programa gera definições 
de funções \textit{C} a partir de templates de funções e o segundo é utilizado no contexto de um programa simples a ser executado por 
  um \textit{robot}. Neste último exemplo, utiliza-se um analisador léxico para fazer \textit{parse} do resultado de um comando de 
  \textit{Linux}, necessário ao funcionamento do \textit{robot}.
\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}
A análise de texto é uma das tarefas mais comuns dos programadores. No entanto, o desenvolvimento de analisadores léxicos com recurso
a linguagens tradicionais tais como C ou Java é um processo demorado e relativamente complexo, muito susceptível a erros. 
Devido a isto e ao facto dos analisadores léxicos serem utilizados em praticamente todas as áreas em que a informática 
é aplicada, torna-se útil o uso de ferramentas tais como o \textit{FLEX} que permitem fácil e rapidamente especificar que padrões 
devem ser reconhecidos e que ações devem ser realizadas quando esses mesmos padrões são encontrados.

Esta abordagem é extremamente vantajosa para os programadores porque muda o foco da implementação do mecanismo de deteção de 
padrões propriamente dito para os padrões que devem ser detetados e as ações a serem executadas. Para além disso, o tempo necessário 
para construir um analisador léxico diminui significativamente, assim como a complexidade e tamanho do código necessário para gerar o 
analisador.
Outra vantagem de utilizar esta ferramenta é a facilidade de manutenção e extensão de analisadores, uma vez que facilmente se adicionam ou mudam
os padrões reconhecidos e as acções associadas a eles.

Por ser extremamente versátil, esta ferramenta pode ser utilizada em vários domínios. Este relatório descreve o uso do 
\textit{FLEX} em dois domínios diferentes. No primeiro caso, construiu-se um processador de \textit{templates} para a linguagem de
programção \textit{C}. No segundo caso, construiu-se um programa a ser executado por um \textit{robot} que utiliza a plataforma \textit{ROS}.
Em particular, esse \textit{robot} faz uso do \textit{output} de um comando \textit{Linux} para determinar o seu comportamento. Esse resultado tem
de ser processado e é para esse fim que se utiliza o \textit{FLEX}.

\section*{Estrutura do Relatório}
O relatório encontra-se dividido em 4 capítulos:
\begin{enumerate}
    \item \nameref{intro} (o capítulo atual);
    \item \nameref{templates_c};
    \item \nameref{robot};
    \item \nameref{concl}.
\end{enumerate}
No capítulo~\ref{templates_c}, explica-se o processo e as decisões de desenvolvimento de um analisador léxico capaz de traduzir funções
definidas por \textit{templates} em funções na síntaxe da linguagem de programação \textit{C}.

No capítulo~\ref{robot}, descreve-se a metodologia e as decisões de desenvolvimento de um analisador léxico 
utilizado por um programa em \textit{C++} a ser executado num robot,
com base na framework \textit{ROS (Robot Operating System)}. Embora esse seja um programa 
relativamente simples, está assente numa plataforma relativamente complexa (\textit{ROS}) pelo que apenas se descreve o analisador léxico
utilizado pelo mesmo.
No capítulo~\ref{concl}, termina-se o relatório com uma síntese do trabalho desenvolvido e com as conclusões do mesmo.

\chapter{Templates em C} \label{templates_c}
\section{Análise e Especificação} \label{ae_af}
\subsection{Descrição Informal do Problema}
Por vezes, na linguagem de programação C, é necessário definir várias funções cujo comportamento é muito semelhante. Isto leva a que
hajam grandes porções de código repetido e a que seja difícil manter o código uma vez que qualquer alteração numa função pode levar a
que seja necessário modificar as outras funções. Uma possível solução a este problema passaria por definir um \textit{template} de funções
para cada conjunto de funções que partilham o mesmo comportamento. Neste trabalho, definiu-se um \textit{template} para definir funções que
devolvem \textit{strings} resultantes da concatenação de expressões passadas no corpo do \textit{template}.
O objetivo deste exercício é construir um analisador léxico capaz de interpretar os templates no formato especificado e produzir as respetivas 
funções em \textit{C}.
\subsection{Formato dos Ficheiros de Input}
Os ficheiros de \textit{input} consistem em ficheiros de código \textit{C} que podem conter definições de funções através de templates
no formato
\begin{verbatim}
Nome_da_Funcao = {{ corpo do template }}
\end{verbatim}
No corpo do \textit{template}, podem-se usar os seguintes padrões:
\begin{itemize}
  \item \texttt{ [\% variavel \%] } - quando este padrão é encontrado, regista-se \texttt{variavel} como um dos argumentos da função
    e o valor de \texttt{variavel} deverá constar no output da função definida no \textit{template}, no local onde o padrão foi detetado;
  \item \texttt{ [\% MAP f c l \%]} - quando ocorre este padrão, regista-se \texttt{c} e \texttt{l} como
    argumentos da função definida pelo \textit{template}
    e coloca-se o resultado da aplicação da função \texttt{f} a todos os elementos da lista \texttt{l} no resultado da função;
  \item \texttt{ [\% C expressao\_em\_c \%] } - quando este padrão é detetado, considera-se que \texttt{expressao\_em\_c} é uma 
    expressão em \textit{C} cujo valor de retorno é uma \textit{string}. No resultado da função que está a ser definida irá constar o
    resultado da expressão em \textit{C}.
\end{itemize}
O texto que não concordar com nenhum destes padrões é considerado como texto que deverá constar no resultado da função tal e qual como está,
sem nenhum tipo de formatação.
\section{Compilação e Instalação}
Para compilar o programa, deve-se invocar o comando \texttt{make} na pasta que tenha o ficheiro \textit{inline\_templates.fl} e a 
seguinte \textit{Makefile}:
\begin{verbatim}
v=inline_templates
$v: $v.fl
  flex --noyywrap $v.fl
  cc lex.yy.c -o $v
  rm lex.yy.c

install: $v
  mkdir -p ~/bin/
  mv $v ~/bin/
\end{verbatim}

Desta forma, é gerado o executável \texttt{inline\_templates}. Também se poderá invocar o comando \texttt{make install} para instalar
o programa numa pasta que conste, preferencialmente, na variável \texttt{PATH}. Por defeito, o executável é instalado na pasta \texttt{~/bin}.
\section{Utilização}
O programa deverá ser invocado da seguinte forma:
\begin{verbatim}
$ ./inline_templates < FICHEIRO_INPUT > FICHEIRO_OUTPUT
\end{verbatim}

O ficheiro \texttt{FICHEIRO\_INPUT} corresponde ao código fonte com utilização de \textit{templates} e o ficheiro \texttt{FICHEIRO\_OUTPUT}
corresponde ao código fonte em que as definições de funções com recurso a templates foram substituídas por funções na síntaxe da linguagem
\textit{C}.
\subsection{Exemplo de Utilização}
Apresenta-se agora um exemplo de utilização do programa \textit{inline\_templates}.
\subsubsection{Input}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>

Fli={{<li> [% ele %] < /li>
}}

Fhtml={{<html>
<head><title>[% tit %]</title></head>
<body>
<h1>[% tit %]</h1>
<ul>[% MAP Fli comp items %]</ul>
</body>
</html>
}}

int main(){
  char * a[]={"expressoes regulares","parsers","compiladores"};
  printf("%s\n",Fhtml("Conteudo programático", 3, a));
}

\end{lstlisting}
\subsubsection{Output}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>
  
char* Fli(char* ele){
   char BUF[10000];
   int j=0;
   int i;
   j += sprintf(BUF+j, "<li> ");
   j += sprintf(BUF+j, "%s", ele);
   j += sprintf(BUF+j, " < /li>\n");
   return strdup(BUF);
}

char* Fhtml(char* tit,int comp,char** items){
    char BUF[10000];
    int j=0;
    int i;
    j += sprintf(BUF+j, "<html>\n");
    j += sprintf(BUF+j, "  <head><title>");
    j += sprintf(BUF+j, "%s", tit);
    j += sprintf(BUF+j, "</title></head>\n");
    j += sprintf(BUF+j, "<body>\n");
    j += sprintf(BUF+j, "  <h1>");
    j += sprintf(BUF+j, "%s", tit);
    j += sprintf(BUF+j, "</h1>\n");
    j += sprintf(BUF+j, "  <ul>");
    for(i=0; i<comp; i++)
        j += sprintf(BUF+j, "%s", Fli(items[i]));
    j += sprintf(BUF+j, "</ul>\n");
    j += sprintf(BUF+j, "</body>\n");
    j += sprintf(BUF+j, "</html>\n");
    return strdup(BUF);
}

int main(){
    char * a[]={"expressoes regulares","parsers","compiladores"};
    printf("%s\n",Fhtml("Conteudo programático", 3, a));
}

\end{lstlisting}
\section{Concepção e Implementação da Resolução}
Passa-se agora a descrever o funcionamento do analisador léxico desenvolvido. O código na sua totalidade pode ser consultado no 
\nameref{cod_fich_template}.

Antes de quaisquer outras considerações, é necessário descrever o funcionamento geral do programa. Sempre que for detetado código \textit{C}
"normal", i.e. que não ocorre dentro de nenhuma definição de funções com recurso ao \textit{template} apresentado,
este será imediatamente impresso no ecrã. Caso seja detetada a definição de uma função com recurso ao \textit{template}, o código da função 
será armazenado em buffers por forma a facilitar a construção do código. São utilizados para o efeito três buffers, um para o cabeçalho da 
função, outro para o corpo e outro para armazenar uma linha da função de cada vez. Desta forma, o cabeçalho e o corpo das funções são construídos
separadamente, evitando cálculos na enumeração dos parâmetros nos cabeçalhos das funções. Quando se chega ao fim da definição da função,
o conteúdo dos buffers é formatado de forma a obedecer à sintaxe da linguagem \textit{C} e a completar a definição da função,
culminando numa função \textit{C} bem formada. Depois disto, a função obtida é impressa no ecrã.

A expressão regular {IDENT} descreve os identificadores que são reconhecidos. Os identificadores são constituídos por uma letra seguida de 0 ou 
mais letras, números ou \textit{underscores}.

Quando o programa inicializa, o analisador léxico estará no estado \texttt{INITIAL}. Neste estado, se encontrar o padrão 
\texttt{<INITIAL>{IDENT}[:space:]*=[:space:]*\{\{}, isto é, se encontrar um identificador seguido de 0 ou mais ocorrências de 
espaços e de um sinal de igual, possivelmente com espaços a seguir, e por fim, duas chavetas, então considera-se que foi encontrada a
definição de uma função através do uso do \textit{template}. Nesse caso, entra-se no contexto \texttt{decl\_funcao} e
inicia-se a construção da função
nos buffers. Concretamente, põe-se o tipo de retorno da função e o nome no buffer do cabeçalho e põe-se a declaração de variáveis
no corpo da função. 

Seguidamente, quando encontrar o padrão \texttt{\textbackslash [\%[:space:]*} vai entrar no estado \texttt{var} e inserir no corpo da função
a instrução para imprimir o que foi lido da linha até ao momento. Caso contrário, o conteúdo lido é posto no buffer de linha e quando a linha 
termina, i.e. quando se encontra um \textit{'\textbackslash n'}, insere-se no corpo da função uma instrução para
imprimir tudo o que foi lido da linha. Se eventualmente encontrar aspas, será inserido no buffer de linha a sequência de escape correspondente
por forma a que quando esta for impressa, o símbolo impresso seja o pretendido.

No estado \texttt{var}, quando um identificador é encontrado, pode-se dar uma de três situações:
\begin{itemize}
  \item o identificador ser \texttt{MAP}, o que identifica um mapeamento;
  \item o identificador ser \texttt{C}, o que sinaliza uma expressão \textit{C} cujo tipo é \texttt{char *};
  \item nenhuma das anteriores, pelo que o identificador corresponde ao nome de uma variável.
\end{itemize}

No primeiro caso,

No segundo caso,

Por fim, caso o identificador

\chapter{Desenvolvimento de programa simples para robot com parsing de resultados} \label{robot}
\section{Análise e Especificação} \label{ae_vv}
\subsection{Descrição Informal do Problema}
\subsection{Especificação dos Requisitos} \label{er_vv}
\subsection{Formato do \textit{input}} \label{form_inp_vv}
\section{Utilização}
\subsection{Exemplos de Utilização}
Referir que os resultados de utilização foram obtidos empiricamente
\section{Concepção e Implementação da Resolução}

\subsection{Codificação} \label{cod_af}
\subsection{Testes}
\chapter{Conclusão} \label{concl}
\appendix

\chapter{Código dos Programas} 

\section{Conteúdo do ficheiro \texttt{inline\_templates.fl}} \label{cod_fich_template}
\begin{lstlisting}
IDENT         [a-zA-Z_][a-zA-Z0-9_]*

%x decl_funcao
%x nome_funcao_encontrado
%x dentro_aspas_funcao
%x map
%x map_funcao_lida
%x map_comprimento_lido
%x var
%x codigo_c

%top{
    #include <stdio.h>
    #include <string.h>
    #define TAMANHO_BUFFER 10000
    #define TAMANHO_MAX_CABECALHO 4096
    #define TAMANHO_MAX_CORPO 20000
    #define TAMANHO_MAX_LINHA_FUNCAO 4096
    #define MAX_VARIAVEIS 1000

    /* usa-se char para armazenar informação do tipo de uma var de forma a poupar memoria */
    typedef char TIPO;
    #define INT 0
    #define STRING 1
    #define LISTA_STRINGS 2 

    char buf_corpo_func[TAMANHO_MAX_CORPO];
    char buf_cabecalho_func[TAMANHO_MAX_CORPO];
    char buf_linha_funcao[TAMANHO_MAX_LINHA_FUNCAO];
    char* nomes_variaveis[MAX_VARIAVEIS]; 
    TIPO tipos_variaveis[MAX_VARIAVEIS];
                                                                        
    /* vars para leitura de mapas */
    char* nome_funcao;
    char* var_comprimento;
    char* nome_lista;
                                                                                          
    int pos_buf_cabecalho = 0;
    int pos_buf_corpo = 0;
    int pos_buf_linha = 0;
    int pos_variaveis = 0;
    int insereVar(char* nome, TIPO tipo);

    /* vars usadas no programa gerado */
    #define NOME_BUFF "BUF"
    #define NOME_VAR1 "j"
    #define NOME_VAR2 "i"

    /* macros uteis para simplificar expressoes */
    #define ADICIONA_CABECALHO(...) pos_buf_cabecalho += sprintf(buf_cabecalho_func + pos_buf_cabecalho, __VA_ARGS__)
    #define ADICIONA_CORPO(...) pos_buf_corpo += sprintf(buf_corpo_func + pos_buf_corpo, __VA_ARGS__);
}

%%

<INITIAL>{IDENT}/[:space:]*=[:space:]*\{\{        {
/* Encontrou um template de uma funcao */
    BEGIN(nome_funcao_encontrado);
    pos_buf_cabecalho = pos_buf_corpo = pos_buf_linha = pos_variaveis = 0;
    ADICIONA_CABECALHO("char* %s(", yytext);
    ADICIONA_CORPO("\tchar "NOME_BUFF"[%d];\n\tint "NOME_VAR1"=0;\n\tint "NOME_VAR2";\n", TAMANHO_BUFFER);
}

<nome_funcao_encontrado>[:space:]*=[:space:]*\{\{        { BEGIN(decl_funcao); }

<decl_funcao>\[%[:space:]*        { 
    BEGIN(var); 
    if(pos_buf_linha != 0) {
        buf_linha_funcao[pos_buf_linha++] = '\0';
        ADICIONA_CORPO("\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\");\n", buf_linha_funcao);
    }
    pos_buf_linha = 0;
}

<decl_funcao>\"        {
    /* no relatorio, explicar convençao das chavetas */
    buf_linha_funcao[pos_buf_linha++] = '\\';
    buf_linha_funcao[pos_buf_linha++] = '\"';
}

<decl_funcao>.        {
    buf_linha_funcao[pos_buf_linha++] = yytext[0];
}

<decl_funcao>\n        {
    buf_linha_funcao[pos_buf_linha++] = '\\';
    buf_linha_funcao[pos_buf_linha++] = 'n';
    buf_linha_funcao[pos_buf_linha++] = '\0';
    ADICIONA_CORPO("\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\");\n", buf_linha_funcao);
    pos_buf_linha = 0; 
}

<var,map_comprimento_lido,codigo_c>[:space:]*%\]        { BEGIN(decl_funcao); }

<var>{IDENT}        {
    if(!strcmp(yytext, "MAP")){
        BEGIN(map);
    } else if(!strcmp(yytext, "C")){
        BEGIN(codigo_c);
    } else {
        insereVar(yytext, STRING);
        ADICIONA_CORPO("\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\", %s);\n", "%%s", yytext);
    }
}

<map>{IDENT}        {
    BEGIN(map_funcao_lida);
    nome_funcao = strdup(yytext);
}

<map_funcao_lida>{IDENT}        {
    BEGIN(map_comprimento_lido);
    var_comprimento = strdup(yytext);
    insereVar(var_comprimento, INT);
}

<map_comprimento_lido>{IDENT}        {
    nome_lista = yytext; 
    insereVar(nome_lista, LISTA_STRINGS);
    ADICIONA_CORPO("\tfor("NOME_VAR2"=0; "NOME_VAR2"<%s; "NOME_VAR2"++)\n", var_comprimento);
    ADICIONA_CORPO("\t\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\", %s(%s["NOME_VAR2"]));\n", "%%s", nome_funcao, nome_lista);
    free(nome_funcao);
    free(var_comprimento);
}

<map_funcao_lida>.        {}

<codigo_c>.*/%\]        {
    ADICIONA_CORPO("\t"NOME_VAR1" += sprintf("NOME_BUFF"+"NOME_VAR1", \"%s\",%s);\n", "%%s", yytext);
}

<decl_funcao>\}\}        {
    BEGIN(INITIAL);

    // completa cabecalho funcao
    int i;
    char* tipo = NULL;
    for(i=0; i < pos_variaveis; i++){
        switch(tipos_variaveis[i]){
            case INT: tipo = "int"; break;
            case STRING: tipo = "char*"; break;
            case LISTA_STRINGS: tipo = "char**"; break;
        }
        ADICIONA_CABECALHO("%s %s,",tipo,nomes_variaveis[i] );
        free(nomes_variaveis[i]);
     }

     switch(buf_cabecalho_func[pos_buf_cabecalho-1]){
         case '(': buf_cabecalho_func[pos_buf_cabecalho++] = ')';
                   break;
         case ',': buf_cabecalho_func[pos_buf_cabecalho-1] = ')';
                   break;
     }

     buf_cabecalho_func[pos_buf_cabecalho++] = '{'; 
     buf_cabecalho_func[pos_buf_cabecalho++] = '\n'; 
     buf_cabecalho_func[pos_buf_cabecalho] = '\0'; 

     // completa corpo funcao
     ADICIONA_CORPO("\treturn strdup("NOME_BUFF");\n}");

     // imprime declaracao funcao
     printf("\n%s", buf_cabecalho_func);
     printf(buf_corpo_func);
}

%%

int insereVar(char* nome, TIPO tipo){
    int i, found=0;
    for(i=0; i < pos_variaveis; i++){
        if(!strcmp(nome,nomes_variaveis[i])){
            found = 1;
            if(tipos_variaveis[i] != tipo){
                fprintf(stderr, "ERRO: Está a usar variáveis iguais de tipos diferentes\n");
                exit(1);
            }
            break;
        } 
    }

    if(!found){
        nomes_variaveis[pos_variaveis] = strdup(nome);
        tipos_variaveis[pos_variaveis++] = tipo;
    }
    return found;
}

int main(){
    yylex();
}

\end{lstlisting}
\newpage

\section{Conteúdo do ficheiro \texttt{.fl}} \label{cod_fich_vv}
\begin{verbatim}

\end{verbatim}

\chapter{\textit{Input} e \textit{output} dos exemplos/testes}

\section{Templates em C}

\subsection{Conteúdo do ficheiro \texttt{input.c}} \label{hendrix_in}
\begin{lstlisting}[language=XML]
\end{lstlisting}


\nocite{*}
\bibliographystyle{ieeetr}
\bibliography{referenciasWeb}

\end{document} 
